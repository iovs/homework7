Веб-приложение "Мини-приложение для Telegram витрина товаров"

Описание:

Создать веб-приложение Telegram для отображения каталога товаров интернет-магазина с ценой, возможностью заказа товара.

Требования:

Веб-интерфейс отображает список товаров интернет-магазина и (категории товаров - вот это под вопросом пока). Есть возможность заказать товар.
Данные о заказе: номер заказа, дата, время, сумма, наименование товара, статус заказа, данные пользователя сохраняются в базе данных, чтобы они были доступны между сессиями.
Данные о товарах: название, ссылка на картинку, цена, количество, возможно описание - сохраняются в базе данных, чтобы они были доступны между сессиями.
Реализована аутентификация пользователей, чтобы каждый пользователь видел только свою историю заказов.
Реализована возможность импорта администратором данных о товарах из формата json/yml/xls/xlsx/csv.
Реализована административная панель, позволяющая отслеживать заказы.
Применение шаблонов HTML для отображения пользовательского интерфейса.
Обработка ошибок и валидация пользовательского ввода, чтобы предотвратить некорректные данные.
Развертывание

Развертывание сервиса должно осуществляться с использованием docker compose в директории с проектом.

Тестирование

Написаны юнит-тесты на core логику приложения. Плюсом будут тесты на транспортном уровне и на уровне хранения.

Критерии оценивания

Максимум - 15 баллов (при условии выполнения обязательных требований):

Реализован алгоритм - 2 балла.
Реализовано разделение на слои (транспортный, хранения и т.д.) - 2 балла.
Реализовано API сервиса - 2 балла.
Реализован пользовательский интерфейс - 2 балла.
Написаны юнит-тесты - 1 балл.
Написаны интеграционные тесты - 2 балла.
Тесты адекватны и полностью покрывают функциональность - 1 балл.
Понятность и чистота кода - до 3 баллов.
Зачёт от 10 баллов# homework5

Структура приложения

# Структура пользователь internal/model/users.go
Поля структуры Пользователь:
- ID пользователя (int)
- Имя (string)
- Телефон (string)

# Категория товара (структура)
Поля структуры категория:
- название категории (string)
- ID категории (int)


# Товары (структура) internal/model/products.go
Поля структуры Товары:
- ID товара (int)
- Поле для привязки товара к категории по ID (int)
- название товара (string)
- ссылка на картинку (картинка) //в бд наверное лучше сохранять ссылку на картинку (string)
- цена (int)
- количество товара (остаток на складе) (int)
- описание товара (string)

# Заказ (структура) internal/model/orders.go
Поля структуры Заказ:
- имя (string)
- ID номер заказа (int)
- количество товара в заказе (int)
- дата и время (time.Time)
- цена (int)
- итоговая сумма (int)
- наименование товара (string)
- статус заказа (принят, отправлен, завершен) (string)
- id пользователя (string)
- телефон (string)
- адрес доставки //не знаю получится ли сделать или нет, тк по уму там надо города списком выводить, подтягивать кладер адресов и городов (string)

# Админка приложения (структура)
//Административный интерфейс позволяет администратору приложения загрузить данные о товарах и категориях из файла или по ссылке, без программирования.
Поля структуры Админка приложения:
- Ссылка на файл/feed (string)
- Файл //Возможность загрузки файла, не знаю, какого типа поле

# Комментарии для себя
# В ДЗ 7 добавлены функции, краткое описание работы:
logger.go
#logger.Start(done)

Заводим «таймер» на 200 мс (time.NewTicker) — он будет «тикать» каждые 200 миллисекунд.
Запускаем бесконечный цикл, который срабатывает по каждому тику этого таймера.
Получаем текущее состояние всех пяти списков (orders, products, categories, users, adminka) с помощью функции Snapshot().
Сравниваем размеры списков с теми, что были на прошлом тике (хранятся в prevO, prevP и т. д.).
Вызываем check и если в каком-то списке появились новые элементы, то check распечатает новые добавленные записи.
Обновляем «предыдущие» размеры списков (prevO = len(os) и т. д.).
Проверяем канал done на предмет того, что он закрыт(делая чтение _, ok := <-done).
Если канал закрыт (!ok == true), значит новых данных больше не будет -> прекращаем логирование.

repository.go
#ReceiveData(ch, done)

Ждёт в цикле, пока из ch приходят объекты model.ID.
Определяет тип через switch v.(type) и добавляет в соответствующий срез.
Печатает в консоль сообщение о добавлении.
Когда канал ch закрывается и элементов больше нет, функция выходит из цикла и закрывает канал done — сигнал другим, что приём завершён.

repository.go
#Snapshot()

Берёт блокировку (mu.Lock()), чтобы другие горутины не могли менять срезы в процессе.
Делает копии всех пяти срезов (чтобы вернуть безопасные для чтения копии) используя append.
Снимает блокировку (mu.Unlock()) и возвращает полученные копии срезов данных.

service.go
#GenerateItems(ch)

Запускает цикл по счётчику i от 1 до 5.
Внутри switch для каждого номера i формирует новую структуру нужного типа.
Отправляет каждую из этих структур в канал ch.
После выхода из цикла defer close(ch) автоматически закрывает канал ch, сигнализируя, что новых элементов в нем больше не будет.







